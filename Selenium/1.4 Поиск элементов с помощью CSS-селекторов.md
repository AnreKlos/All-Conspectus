## Поиск элементов с помощью CSS-селекторов

Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

- id
- tag
- значение атрибута
- name
- class

### Поиск по id

У элемента есть атрибут **`id="bullet"`**, значит, мы можем найти её с помощью селектора **`#bullet`** (знак **`#`** означает, что мы ищем по **`id`** со значением **`bullet`**).

>Можно проверить правильность подобранного селектора непосредственно в браузере в консоли разработчика. Откройте консоль разработчика и перейдите в ней на вкладку Elements. Затем нажмите ctrl+F и в открывшейся внизу поисковой строке введите селектор. Если селектор написан правильно, то вы увидите подсвеченный элемент на веб-странице, а также элемент будет подсвечен жёлтым цветом в html-коде. Еще в поисковой строке вы увидите количество найденных элементов. Желательно писать точные селекторы, которые позволяют найти ровно один элемент.

### Поиск по tag

Чтобы найти элемент по тегу, напишите название тега в поисковой строке, как мы делали это при поиске по `id` (только без знака `#`), например, `h1`. Поиск по `h1` найдёт для нас элемент с названием страницы. Поиск по тегам не очень удобен, т.к. разработчики используют небольшое количество тегов для разметки страниц, и скорее всего, одному тегу будет соответствовать множество элементов.

### Поиск по значению атрибута

Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по `id` в следующем виде `[id="bullet"]` вместо `#bullet`.

Лучше использовать вариант с квадратными скобками при поиске значения атрибута для тех атрибутов, у которых нет собственных коротких команд поиска. Например, давайте найдем элемент `h1` по значению его атрибута `value`: `[value="Cat memes"]`.

### Поиск по name

Этот вариант поиска является разновидностью поиска по значению атрибута и записывается так же: `[name="bullet-cat"]`. Мы выделяем этот вариант потому что он довольно часто используется, а также выделяется как отдельный вид поиска элементов в Selenium WebDriver.

### Поиск по class

Поиск по классу можно записать в виде `[class="jumbotron-heading"]`, так как class тоже является атрибутом элемента. Но раз уж классы используются практически в каждой странице при задании стилей страниц, то для них также имеется свой короткий вариант поиска: `.jumbotron-heading`. То есть мы пишем значение класса и предваряем его точкой.

Давайте рассмотрим важную разницу между двумя способами поиска по классу. Допустим, у элемента article задано больше одного класса, как на странице http://suninjuly.github.io/cats.html:

```<article id="moto" class="lead text-muted" title="one-thing" name="moto">If there's one thing that the internet was made for, it's funny cat memes.</article>```

Вариант `[class="lead"]` не найдет нам этот элемент, так как он ищет по точному совпадению. Чтобы найти элемент, нам нужно будет написать `[class="lead text-muted"]`, порядок классов при этом важен. `[class="text-muted lead"]` — уже не найдет искомый элемент.
Вариант .lead при этом позволит найти данный элемент, так как он ищет простое вхождение класса в элемент. Для уточнения селектора можно задать также оба класса, для этого нужно добавить второй класс к строке поиска без пробела и предварить его точкой: .lead.text-muted. Порядок классов в отличие от первого способа здесь не важен — .text-muted.lead так же найдет нужный элемент. Рекомендуем пользоваться вторым способом поиска классов, так как он является более гибким.

> Важное замечание. Поиск по классу чувствителен к регистру, то есть `.Lead` уже не найдет нужный элемент.

В консоли браузера вы также можете искать по простому совпадению текста в HTML, например, запрос lead подсветит текст lead. Однако, не стоит пользоваться таким поиском для выбора элементов, так как он слишком общий и не может использоваться в качестве селектора.

Мы рассмотрели разные варианты написания пути к элементу на странице, используя синтаксис CSS, т.е. научились писать CSS-селекторы. Слово "селектор" является буквальным переводом от английского слова selector. Selector в свою очередь происходит от глагола select, что переводится как "выбирать".

---

## Поиск элементов с помощью составных CSS-селекторов
Предположим, что не можем найти элемент на странице, используя простой селектор, так как такой селектор находит сразу несколько элементов. Ниже мы привели часть кода простой HTML-страницы, описывающей блог. 

Вопрос: как нам найти селектор для подписи у второй картинки? Вот здесь нам поможет иерархическая структура страницы и возможность комбинировать CSS-селекторы. CSS-селекторы позволяют использовать одновременно любые селекторы, рассмотренные ранее, а также имеют некоторые дополнительные возможности для уточнения поиска.
```
<div id="posts" class="post-list">
  <div id="post1" class="item">
    <div class="title">Как я провел лето</div>
    <img src="./images/summer.png">
  </div>
  <div id="post2" class="item">
    <div class="title second">Ходили купаться</div>
    <img src="./images/bad_dog.jpg">
  </div>
  <div id="post3" class="item">
    <div class="title">С друзьями</div>
    <img src="./images/friends.jpg">
  </div>
</div>
```
### Использование потомков

Попробуем найти элемент с текстом "Ходили купаться". Для решения этой задачи мы можем взять элемент, стоящий выше в иерархии нужного нам элемента, и написать следующий селектор:

`#post2 .title`

Здесь символ `#` означает, что надо искать элемент с `id post2`, `пробел` - что также нужно найти элемент-потомок, а `.`, что элемент-потомок должен иметь класс со значением `title`.

Элемент `.title` называется потомком (англ. descendant) элемента `#post2`. Потомок может находиться на любом уровне вложенности, все элементы с селектором `.title` также являются и потомками элемента `#posts`, хотя и расположены от него на два уровня ниже. `#posts .title` найдет все 3 элемента с классом `title`.

>!Внимание. Символ пробела " " является значащим в CSS-селекторах. Это важный символ, который разделяет описание предка и потомка. Если бы мы записали селектор `#post2.title` без пробела, то в данном примере не было найдено ни одного элемента. Такая запись означала бы, что мы хотим найти элемент, который одновременно содержит `id "post2"` и `класс "title"`. Таким образом `#post2 .title` и `#post2.title` — это разные селекторы.

### Использование дочерних элементов

Другой способ найти этот элемент:

`#post2 > div.title`

Здесь мы указали еще тег элемента `div` и уточнили, что нужно взять элемент с тегом и классом: `div.title`, который находится строго на один уровень иерархии ниже чем элемент `#post2`. Для этого используется символ `>`.

Элемент `#post2` в этом случае называется родителем (англ. parent) для элемента `div.title`, а элемент `div.title` называется дочерним элементом (англ. child) для элемента `#post2`. ***Если символа `>` нет, то будет выполнен поиск всех элементов `div.title` на любом уровне ниже первого элемента.***

>!Внимание. В данном случае символы пробела вокруг символа "`>`" не несут важного значения в отличие от предыдущего примера, и могут быть опущены. Запись `#post2>div.title` аналогична записи `#post2 > div.title`.

### Использование порядкового номера дочернего элемента

Еще один способ найти этот элемент:

`#posts > .item:nth-child(2) > .title`

Псевдо-класс `:nth-child(2)` — позволяет найти второй по порядку элемент среди дочерних элементов для `#posts`. Затем с помощью конструкции `> .title` мы указываем, что нам нужен элемент `.title`, родителем которого является найденный ранее элемент `.item`.

### Использование нескольких классов

Также мы можем использовать сразу несколько классов элемента, чтобы его найти. Для этого классы записываются подряд через точку: `.title.second`

Мы рассмотрели базовые селекторы, которых будет достаточно для написания простых UI-тестов. Если вы захотите разобраться подробнее в css-селекторах, то мы рекомендуем вам посмотреть следующие статьи:

https://learn.javascript.ru/css-selectors

https://www.w3schools.com/cssref/css_selectors.asp

https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Selectors
